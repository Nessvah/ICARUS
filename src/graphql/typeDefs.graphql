
    input ComparisonOperators {
      _eq: String
_neq: String
_lt: String
_lte: String
_gt: String
_gte: String
_in: String
_nin: String
_like: String
    }


# define the root Query
type Query {
  tables: [TableInfo]
    categories(input: CategoriesListOptions = {}): [Categories]
customers(input: CustomersListOptions = {}): [Customers]
order_items(input: Order_itemsListOptions = {}): [Order_items]
orders(input: OrdersListOptions = {}): [Orders]
payment(input: PaymentListOptions = {}): [Payment]
product_reviews(input: Product_reviewsListOptions = {}): [Product_reviews]
products(input: ProductsListOptions = {}): [Products]
shipments(input: ShipmentsListOptions = {}): [Shipments]
users(input: UsersListOptions = {}): [Users]
user_role(input: User_roleListOptions = {}): [User_role]
    categoriesCount(input: CategoriesCount): CategoriesCountResult
customersCount(input: CustomersCount): CustomersCountResult
order_itemsCount(input: Order_itemsCount): Order_itemsCountResult
ordersCount(input: OrdersCount): OrdersCountResult
paymentCount(input: PaymentCount): PaymentCountResult
product_reviewsCount(input: Product_reviewsCount): Product_reviewsCountResult
productsCount(input: ProductsCount): ProductsCountResult
shipmentsCount(input: ShipmentsCount): ShipmentsCountResult
usersCount(input: UsersCount): UsersCountResult
user_roleCount(input: User_roleCount): User_roleCountResult

}

# define the root Muation
type Mutation {
  authorize(input: AuthorizeUser!): AuthPayload!
    categories(input: CategoriesMutationOptions): CategoriesOutput
customers(input: CustomersMutationOptions): CustomersOutput
order_items(input: Order_itemsMutationOptions): Order_itemsOutput
orders(input: OrdersMutationOptions): OrdersOutput
payment(input: PaymentMutationOptions): PaymentOutput
product_reviews(input: Product_reviewsMutationOptions): Product_reviewsOutput
products(input: ProductsMutationOptions): ProductsOutput
shipments(input: ShipmentsMutationOptions): ShipmentsOutput
users(input: UsersMutationOptions): UsersOutput
user_role(input: User_roleMutationOptions): User_roleOutput
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     category_id: ComparisonOperators
category_name: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input CategoriesCount {
    _action: ActionType!
  } 


  type CategoriesCountResult {
   action: String
    count: Int!
  }


input CategoriesLogicalOp {
  _and: [ CategoriesLogicalOp]
  _or: [ CategoriesLogicalOp]
   category_id: ComparisonOperators
category_name: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input CategoriesMutationOptions {
    filter: CategoriesFilter
    _action: ActionType!
    sort: CategoriesSortOptions
    category_name: String
icon_class: String
icon_label: String
    }

input CategoriesSortOptions {
  category_id: Sort
category_name: Sort
icon_class: Sort
icon_label: Sort
}

input CategoriesListOptions {
    filter: CategoriesFilter
    skip: Int
    take: Int = 15
    sort: CategoriesSortOptions
    }

type Categories {
    category_id: ID!
category_name: String!
icon_class: String
icon_label: String
}

input CategoriesInput {
    category_name: String!
icon_class: String
icon_label: String
}

input CategoriesFilter {
  _and: [ CategoriesLogicalOp]
  _or: [ CategoriesLogicalOp]
}

input CategoriesUpdate {
    category_name: String
icon_class: String
icon_label: String
}

type CategoriesOutput {
	created: [Categories]!
	updated: [Categories]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     customer_id: ComparisonOperators
customer_name: ComparisonOperators
email: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input CustomersCount {
    _action: ActionType!
  } 


  type CustomersCountResult {
   action: String
    count: Int!
  }


input CustomersLogicalOp {
  _and: [ CustomersLogicalOp]
  _or: [ CustomersLogicalOp]
   customer_id: ComparisonOperators
customer_name: ComparisonOperators
email: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input CustomersMutationOptions {
    filter: CustomersFilter
    _action: ActionType!
    sort: CustomersSortOptions
    customer_name: String
email: String
icon_class: String
icon_label: String
    }

input CustomersSortOptions {
  customer_id: Sort
customer_name: Sort
email: Sort
icon_class: Sort
icon_label: Sort
}

input CustomersListOptions {
    filter: CustomersFilter
    skip: Int
    take: Int = 15
    sort: CustomersSortOptions
    }

type Customers {
    customer_id: Int!
customer_name: String!
email: String!
icon_class: String
icon_label: String
}

input CustomersInput {
    customer_name: String!
email: String!
icon_class: String
icon_label: String
}

input CustomersFilter {
  _and: [ CustomersLogicalOp]
  _or: [ CustomersLogicalOp]
}

input CustomersUpdate {
    customer_name: String
email: String
icon_class: String
icon_label: String
}

type CustomersOutput {
	created: [Customers]!
	updated: [Customers]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     order_item_id: ComparisonOperators
order_id: ComparisonOperators
product_id: ComparisonOperators
quantity: ComparisonOperators
price: ComparisonOperators
currency_type: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input Order_itemsCount {
    _action: ActionType!
  } 


  type Order_itemsCountResult {
   action: String
    count: Int!
  }


input Order_itemsLogicalOp {
  _and: [ Order_itemsLogicalOp]
  _or: [ Order_itemsLogicalOp]
   order_item_id: ComparisonOperators
order_id: ComparisonOperators
product_id: ComparisonOperators
quantity: ComparisonOperators
price: ComparisonOperators
currency_type: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input Order_itemsMutationOptions {
    filter: Order_itemsFilter
    _action: ActionType!
    sort: Order_itemsSortOptions
    order_id: Int
product_id: Int
quantity: Int
price: Float
currency_type: String
icon_class: String
icon_label: String
    }

input Order_itemsSortOptions {
  order_item_id: Sort
order_id: Sort
product_id: Sort
quantity: Sort
price: Sort
currency_type: Sort
icon_class: Sort
icon_label: Sort
}

input Order_itemsListOptions {
    filter: Order_itemsFilter
    skip: Int
    take: Int = 15
    sort: Order_itemsSortOptions
    }

type Order_items {
    order_item_id: Int!
order_id: Int
product_id: Int
quantity: Int!
price: Float!
currency_type: String!
icon_class: String
icon_label: String
}

input Order_itemsInput {
    order_id: Int
product_id: Int
quantity: Int!
price: Float!
currency_type: String!
icon_class: String
icon_label: String
}

input Order_itemsFilter {
  _and: [ Order_itemsLogicalOp]
  _or: [ Order_itemsLogicalOp]
}

input Order_itemsUpdate {
    order_id: Int
product_id: Int
quantity: Int
price: Float
currency_type: String
icon_class: String
icon_label: String
}

type Order_itemsOutput {
	created: [Order_items]!
	updated: [Order_items]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     order_id: ComparisonOperators
order_date: ComparisonOperators
customer_id: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input OrdersCount {
    _action: ActionType!
  } 


  type OrdersCountResult {
   action: String
    count: Int!
  }


input OrdersLogicalOp {
  _and: [ OrdersLogicalOp]
  _or: [ OrdersLogicalOp]
   order_id: ComparisonOperators
order_date: ComparisonOperators
customer_id: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input OrdersMutationOptions {
    filter: OrdersFilter
    _action: ActionType!
    sort: OrdersSortOptions
    order_date: String
customer_id: Int
icon_class: String
icon_label: String
    }

input OrdersSortOptions {
  order_id: Sort
order_date: Sort
customer_id: Sort
icon_class: Sort
icon_label: Sort
}

input OrdersListOptions {
    filter: OrdersFilter
    skip: Int
    take: Int = 15
    sort: OrdersSortOptions
    }

type Orders {
    order_id: Int!
order_date: String!
customer_id: Int
icon_class: String
icon_label: String
}

input OrdersInput {
    order_date: String!
customer_id: Int
icon_class: String
icon_label: String
}

input OrdersFilter {
  _and: [ OrdersLogicalOp]
  _or: [ OrdersLogicalOp]
}

input OrdersUpdate {
    order_date: String
customer_id: Int
icon_class: String
icon_label: String
}

type OrdersOutput {
	created: [Orders]!
	updated: [Orders]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     id: ComparisonOperators
order_id: ComparisonOperators
payment_method: ComparisonOperators
payment_date: ComparisonOperators
amount: ComparisonOperators
payment_status: ComparisonOperators
  }


  input PaymentCount {
    _action: ActionType!
  } 


  type PaymentCountResult {
   action: String
    count: Int!
  }


input PaymentLogicalOp {
  _and: [ PaymentLogicalOp]
  _or: [ PaymentLogicalOp]
   id: ComparisonOperators
order_id: ComparisonOperators
payment_method: ComparisonOperators
payment_date: ComparisonOperators
amount: ComparisonOperators
payment_status: ComparisonOperators
}

input PaymentMutationOptions {
    filter: PaymentFilter
    _action: ActionType!
    sort: PaymentSortOptions
    order_id: Int
payment_method: String
payment_date: String
amount: Int
payment_status: String
    }

input PaymentSortOptions {
  id: Sort
order_id: Sort
payment_method: Sort
payment_date: Sort
amount: Sort
payment_status: Sort
}

input PaymentListOptions {
    filter: PaymentFilter
    skip: Int
    take: Int = 15
    sort: PaymentSortOptions
    }

type Payment {
    id: String!
order_id: Int!
payment_method: String!
payment_date: String!
amount: Int!
payment_status: String!
}

input PaymentInput {
    order_id: Int!
payment_method: String!
payment_date: String!
amount: Int!
payment_status: String!
}

input PaymentFilter {
  _and: [ PaymentLogicalOp]
  _or: [ PaymentLogicalOp]
}

input PaymentUpdate {
    order_id: Int
payment_method: String
payment_date: String
amount: Int
payment_status: String
}

type PaymentOutput {
	created: [Payment]!
	updated: [Payment]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     review_id: ComparisonOperators
product_id: ComparisonOperators
customer_id: ComparisonOperators
rating: ComparisonOperators
review_text: ComparisonOperators
review_date: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input Product_reviewsCount {
    _action: ActionType!
  } 


  type Product_reviewsCountResult {
   action: String
    count: Int!
  }


input Product_reviewsLogicalOp {
  _and: [ Product_reviewsLogicalOp]
  _or: [ Product_reviewsLogicalOp]
   review_id: ComparisonOperators
product_id: ComparisonOperators
customer_id: ComparisonOperators
rating: ComparisonOperators
review_text: ComparisonOperators
review_date: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input Product_reviewsMutationOptions {
    filter: Product_reviewsFilter
    _action: ActionType!
    sort: Product_reviewsSortOptions
    product_id: Int
customer_id: Int
rating: Int
review_text: String
review_date: String
icon_class: String
icon_label: String
    }

input Product_reviewsSortOptions {
  review_id: Sort
product_id: Sort
customer_id: Sort
rating: Sort
review_text: Sort
review_date: Sort
icon_class: Sort
icon_label: Sort
}

input Product_reviewsListOptions {
    filter: Product_reviewsFilter
    skip: Int
    take: Int = 15
    sort: Product_reviewsSortOptions
    }

type Product_reviews {
    review_id: Int!
product_id: Int!
customer_id: Int!
rating: Int!
review_text: String!
review_date: String!
icon_class: String
icon_label: String
}

input Product_reviewsInput {
    product_id: Int!
customer_id: Int!
rating: Int!
review_text: String!
review_date: String!
icon_class: String
icon_label: String
}

input Product_reviewsFilter {
  _and: [ Product_reviewsLogicalOp]
  _or: [ Product_reviewsLogicalOp]
}

input Product_reviewsUpdate {
    product_id: Int
customer_id: Int
rating: Int
review_text: String
review_date: String
icon_class: String
icon_label: String
}

type Product_reviewsOutput {
	created: [Product_reviews]!
	updated: [Product_reviews]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     product_id: ComparisonOperators
product_name: ComparisonOperators
price: ComparisonOperators
currency_type: ComparisonOperators
description: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input ProductsCount {
    _action: ActionType!
  } 


  type ProductsCountResult {
   action: String
    count: Int!
  }


input ProductsLogicalOp {
  _and: [ ProductsLogicalOp]
  _or: [ ProductsLogicalOp]
   product_id: ComparisonOperators
product_name: ComparisonOperators
price: ComparisonOperators
currency_type: ComparisonOperators
description: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input ProductsMutationOptions {
    filter: ProductsFilter
    _action: ActionType!
    sort: ProductsSortOptions
    product_name: String
price: Float
currency_type: String
description: String
icon_class: String
icon_label: String
    }

input ProductsSortOptions {
  product_id: Sort
product_name: Sort
price: Sort
currency_type: Sort
description: Sort
icon_class: Sort
icon_label: Sort
}

input ProductsListOptions {
    filter: ProductsFilter
    skip: Int
    take: Int = 15
    sort: ProductsSortOptions
    }

type Products {
    product_id: ID!
product_name: String!
price: Float!
currency_type: String!
description: String!
icon_class: String
icon_label: String
}

input ProductsInput {
    product_name: String!
price: Float!
currency_type: String!
description: String!
icon_class: String
icon_label: String
}

input ProductsFilter {
  _and: [ ProductsLogicalOp]
  _or: [ ProductsLogicalOp]
}

input ProductsUpdate {
    product_name: String
price: Float
currency_type: String
description: String
icon_class: String
icon_label: String
}

type ProductsOutput {
	created: [Products]!
	updated: [Products]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     shipment_id: ComparisonOperators
order_id: ComparisonOperators
shipment_date: ComparisonOperators
tracking_int: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
  }


  input ShipmentsCount {
    _action: ActionType!
  } 


  type ShipmentsCountResult {
   action: String
    count: Int!
  }


input ShipmentsLogicalOp {
  _and: [ ShipmentsLogicalOp]
  _or: [ ShipmentsLogicalOp]
   shipment_id: ComparisonOperators
order_id: ComparisonOperators
shipment_date: ComparisonOperators
tracking_int: ComparisonOperators
icon_class: ComparisonOperators
icon_label: ComparisonOperators
}

input ShipmentsMutationOptions {
    filter: ShipmentsFilter
    _action: ActionType!
    sort: ShipmentsSortOptions
    order_id: Int
shipment_date: String
tracking_int: String
icon_class: String
icon_label: String
    }

input ShipmentsSortOptions {
  shipment_id: Sort
order_id: Sort
shipment_date: Sort
tracking_int: Sort
icon_class: Sort
icon_label: Sort
}

input ShipmentsListOptions {
    filter: ShipmentsFilter
    skip: Int
    take: Int = 15
    sort: ShipmentsSortOptions
    }

type Shipments {
    shipment_id: Int!
order_id: Int!
shipment_date: String!
tracking_int: String!
icon_class: String
icon_label: String
}

input ShipmentsInput {
    order_id: Int!
shipment_date: String!
tracking_int: String!
icon_class: String
icon_label: String
}

input ShipmentsFilter {
  _and: [ ShipmentsLogicalOp]
  _or: [ ShipmentsLogicalOp]
}

input ShipmentsUpdate {
    order_id: Int
shipment_date: String
tracking_int: String
icon_class: String
icon_label: String
}

type ShipmentsOutput {
	created: [Shipments]!
	updated: [Shipments]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     id: ComparisonOperators
password: ComparisonOperators
email: ComparisonOperators
role_id: ComparisonOperators
customer_id: ComparisonOperators
created_at: ComparisonOperators
  }


  input UsersCount {
    _action: ActionType!
  } 


  type UsersCountResult {
   action: String
    count: Int!
  }


input UsersLogicalOp {
  _and: [ UsersLogicalOp]
  _or: [ UsersLogicalOp]
   id: ComparisonOperators
password: ComparisonOperators
email: ComparisonOperators
role_id: ComparisonOperators
customer_id: ComparisonOperators
created_at: ComparisonOperators
}

input UsersMutationOptions {
    filter: UsersFilter
    _action: ActionType!
    sort: UsersSortOptions
    email: String
role_id: Int
customer_id: Int
created_at: String
    }

input UsersSortOptions {
  id: Sort
password: Sort
email: Sort
role_id: Sort
customer_id: Sort
created_at: Sort
}

input UsersListOptions {
    filter: UsersFilter
    skip: Int
    take: Int = 15
    sort: UsersSortOptions
    }

type Users {
    id: ID!
email: String
role_id: Int
customer_id: Int
created_at: String
}

input UsersInput {
    password: String
email: String
role_id: Int
customer_id: Int
created_at: String
}

input UsersFilter {
  _and: [ UsersLogicalOp]
  _or: [ UsersLogicalOp]
}

input UsersUpdate {
    password: String
email: String
role_id: Int
customer_id: Int
created_at: String
}

type UsersOutput {
	created: [Users]!
	updated: [Users]!
	deleted: Int
}

  input NestedFiltering {
    _and: [NestedFiltering]
    _or: [NestedFiltering]
     id: ComparisonOperators
role_name: ComparisonOperators
  }


  input User_roleCount {
    _action: ActionType!
  } 


  type User_roleCountResult {
   action: String
    count: Int!
  }


input User_roleLogicalOp {
  _and: [ User_roleLogicalOp]
  _or: [ User_roleLogicalOp]
   id: ComparisonOperators
role_name: ComparisonOperators
}

input User_roleMutationOptions {
    filter: User_roleFilter
    _action: ActionType!
    sort: User_roleSortOptions
    role_name: String
    }

input User_roleSortOptions {
  id: Sort
role_name: Sort
}

input User_roleListOptions {
    filter: User_roleFilter
    skip: Int
    take: Int = 15
    sort: User_roleSortOptions
    }

type User_role {
    id: ID!
role_name: String!
}

input User_roleInput {
    role_name: String!
}

input User_roleFilter {
  _and: [ User_roleLogicalOp]
  _or: [ User_roleLogicalOp]
}

input User_roleUpdate {
    role_name: String
}

type User_roleOutput {
	created: [User_role]!
	updated: [User_role]!
	deleted: Int
}

enum ActionType {
  COUNT
  CREATE
  UPDATE
  DELETE
}

enum Sort {
  ASC
  DESC
}

input AuthorizeUser {
  email: String!
  password: String!
}

input RoleInput {
  role: String!
}

type AuthPayload {
  token: Token!
}


type Token {
  accessToken: String!
  idToken: String!
  refreshToken: String!

}

  type TableInfo {
    table: String
    structure: String
  }